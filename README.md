# Задачи на Go: анализ вывода, устройство языка и разработка утилит

## 2.1 **Вывод программы**

> **Задача:** Что выведет программа?

_Объясните вывод программы:_
```go
package main

import "fmt"

func main() {
  a := [5]int{76, 77, 78, 79, 80}
  var b []int = a[1:4]
  fmt.Println(b)
}
```

**Ответ:** срез `b` создается из массива `a` с индексами `от 1 до 3` (включительно), 
так как синтаксис среза `[1:4]` включает элементы с индексом `1` (значение 77) 
до индекса `4 не включительно` (т.е. индексы `1, 2, 3`). 
Таким образом, в срез попадают значения `77, 78, 79`

---

## 2.2 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить порядок выполнения defer функций и итоговый вывод:_
```go
package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())
  fmt.Println(anotherTest())
}
```

**Ответ:** 

**Решение:** 

---

## 2.3 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов._
```go
package main

import (
  "fmt"
  "os"
)

func Foo() error {
  var err *os.PathError = nil
  return err
}

func main() {
  err := Foo()
  fmt.Println(err)
  fmt.Println(err == nil)
}
```

---

## 2.4 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить вывод программы._

```go
func main() {
  ch := make(chan int)
  go func() {
    for i := 0; i &lt; 10; i++ {
    ch &lt;- i
  }
}()
  for n := range ch {
    println(n)
  }
}
```

---

## 2.5 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить вывод программы._

```go
package main

type customError struct {
  msg string
}

func (e *customError) Error() string {
  return e.msg
}

func test() *customError {
  // ... do something
  return nil
}

func main() {
  var err error
  err = test()
  if err != nil {
    println("error")
    return
  }
  println("ok")
}
```

---

## 2.6 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить поведение срезов при передаче их в функцию._

```go
package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```

---

## 2.7 **Вывод программы**

> **Задача:** Что выведет программа?

_Объяснить работу конвейера с использованием select._
```go
package main

import (
  "fmt"
  "math/rand"
  "time"
)

func asChan(vs ...int) &lt;-chan int {
  c := make(chan int)
  go func() {
    for _, v := range vs {
      c &lt;- v
      time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
    }
  close(c)
}()
  return c
}

func merge(a, b &lt;-chan int) &lt;-chan int {
  c := make(chan int)
  go func() {
    for {
      select {
        case v, ok := &lt;-a:
          if ok {
            c &lt;- v
          } else {
            a = nil
          }
        case v, ok := &lt;-b:
          if ok {
            c &lt;- v
          } else {
            b = nil
          }
        }
        if a == nil &amp;&amp; b == nil {
          close(c)
          return
        }
     }
   }()
  return c
}

  func main() {
    rand.Seed(time.Now().Unix())
    a := asChan(1, 3, 5, 7)
    b := asChan(2, 4, 6, 8)
    c := merge(a, b)
    for v := range c {
    fmt.Print(v)
  }
}
```

---

## 2.8 **Получение точного времени (NTP)**

> **Задача:** Создать программу, печатающую **точное текущее время** с использованием NTP-сервера.

* Реализовать проект как модуль Go.
* Использовать библиотеку `ntp` для получения времени.
* Программа должна выводить текущее время, полученное через NTP (Network Time Protocol).
* Необходимо обрабатывать ошибки библиотеки: в случае ошибки вывести её текст в STDERR и вернуть ненулевой код выхода.
* Код должен проходить проверки (vet и golint), т.е. быть написан идиоматически корректно.

---

## 2.9 **Распаковка строки**

> **Задача:** Написать функцию Go, осуществляющую примитивную **распаковку строки**, содержащей повторяющиеся символы/руны.

Примеры работы функции:

* Вход: "a4bc2d5e"
  - Выход: "aaaabccddddde"

* Вход: "abcd"
  - Выход: "abcd" (нет цифр — ничего не меняется)

* Вход: "45"
  - Выход: "" (некорректная строка, т.к. в строке только цифры — функция должна вернуть ошибку)

* Вход: ""
  - Выход: "" (пустая строка -> пустая строка)

### Дополнительное задание
_Поддерживать **escape-последовательности** вида \:_
* Вход: "qwe\4\5"
  - Выход: "qwe45" (4 и 5 не трактуются как числа, т.к. экранированы)

* Вход: "qwe\45"
  - Выход: "qwe44444" (\4 экранирует 4, поэтому распаковывается только 5)

### Требования к реализации
Функция должна корректно обрабатывать ошибочные случаи (возвращать ошибку, например, через error), и проходить unit-тесты.

Код должен быть статически анализируем (vet, golint).

---

## 2.10 **Утилита sort**

> **Задача:** Реализовать упрощённый аналог UNIX-утилиты sort (сортировка строк).

Программа должна читать строки (из файла или STDIN) и выводить их отсортированными.

**Обязательные флаги (как в GNU sort):**

* -k N — сортировать по столбцу (колонке) №N (разделитель — табуляция по умолчанию).
Например, «sort -k 2» отсортирует строки по второму столбцу каждой строки.

* -n — сортировать по числовому значению (строки интерпретируются как числа).

* -r — сортировать в обратном порядке (reverse).

* -u — не выводить повторяющиеся строки (только уникальные).

**Дополнительные флаги:**

* -M — сортировать по названию месяца (Jan, Feb, ... Dec), т.е. распознавать специфический формат дат.

* -b — игнорировать хвостовые пробелы (trailing blanks).

* -c — проверить, отсортированы ли данные; если нет, вывести сообщение об этом.

* -h — сортировать по числовому значению с учётом суффиксов (например, К = килобайт, М = мегабайт — человекочитаемые размеры).

Программа должна корректно обрабатывать комбинации флагов (например, -nr — числовая сортировка в обратном порядке, и т.д.).

Необходимо предусмотреть эффективную обработку больших файлов.

Код должен проходить все тесты, а также проверки go vet и golint (понимание, что требуются надлежащие комментарии, имена и структура программы).

---

## 2.11 **Поиск анаграмм в словаре**

> **Задача:** Напишите функцию, которая находит все множества анаграмм по заданному словарю.

### Требования
* На вход подается срез строк (слов на русском языке в Unicode).

* На выходе: map-множество -> список, где ключом является первое встреченное слово множества, а значением — срез из всех слов, принадлежащих этому множеству анаграмм, отсортированных по возрастанию.

* Множества из одного слова не должны выводиться (т.е. если нет анаграмм, слово игнорируется).

* Все слова нужно привести к нижнему регистру.

**Пример:**

* Вход: ["пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"]
Результат (ключи в примере могут быть в другом порядке):
– "пятак": ["пятак", "пятка", "тяпка"]
– "листок": ["листок", "слиток", "столик"]

* Слово «стол» отсутствует в результатах, так как не имеет анаграмм.

Для решения задачи потребуется умение работать со строками, сортировать
и использовать структуры данных (map).

Оценим эффективность: решение должно работать за линейно-логарифмическое время относительно количества слов (допустимо n * m log m, где m — средняя длина слова для сортировки букв).

---

## 2.12 **Утилита grep**

> **Задача:** Реализовать утилиту фильтрации текстового потока (аналог команды grep).

Программа должна читать входной поток (STDIN или файл) и выводить строки, соответствующие заданному шаблону (подстроке или регулярному выражению).

**Необходимо поддерживать следующие флаги:**

* -A N — после каждой найденной строки дополнительно вывести N строк после неё (контекст).

* -B N — вывести N строк до каждой найденной строки.

* -C N — вывести N строк контекста вокруг найденной строки (включает и до, и после; эквивалентно -A N -B N).

* -c — выводить только то количество строк, что совпадающих с шаблоном (т.е. вместо самих строк — число).

* -i — игнорировать регистр.

* -v — инвертировать фильтр: выводить строки, не содержащие шаблон.

* -F — воспринимать шаблон как фиксированную строку, а не регулярное выражение (т.е. выполнять точное совпадение подстроки).

* -n — выводить номер строки перед каждой найденной строкой.

Программа должна поддерживать сочетания флагов (например, -C 2 -n -i – 2 строки контекста, вывод номеров, без учета регистра и т.д.).

Результат работы должен максимально соответствовать поведению команды UNIX grep.

Обязательно учесть пограничные случаи (начало/конец файла для контекста, повторяющиеся совпадения и пр.).

Код должен быть чистым, отформатированным (gofmt), работать без ситуаций гонки и успешно проходить golint.

---

## 2.13 **Утилита cut**

> **Задача:** Реализовать утилиту, которая считывает входные данные (STDIN) и разбивает каждую строку по заданному разделителю, после чего выводит определённые поля (колонки).

**Аналог команды cut с поддержкой флагов:**

* -f "fields" — указание номеров полей (колонок), которые нужно вывести. Номера через запятую, можно диапазоны.
Например: «-f 1,3-5» — вывести 1-й и с 3-го по 5-й столбцы.

* -d "delimiter" — использовать другой разделитель (символ). По умолчанию разделитель — табуляция ('\t').

* -s – (separated) только строки, содержащие разделитель. Если флаг указан, то строки без разделителя игнорируются (не выводятся).

Программа должна корректно парсить аргументы, поддерживать различные комбинации (например, несколько отдельных полей и диапазонов), учитывать, что номера полей могут выходить за границы (в таком случае эти поля просто игнорируются).

Стоит обратить внимание на эффективность при обработке больших файлов. Все стандартные требования по качеству кода и тестам также применимы.

---

## 2.14 **Функция or (объединение done-каналов)**

> **Задача:** Реализовать функцию, которая будет объединять один или более каналов done (каналов сигнала завершения) в один. Возвращаемый канал должен закрываться, как только **закроется любой из исходных каналов**.

_Сигнатура функции может быть такой:_
```go
var or func(channels ...&lt;-chan interface{}) &lt;-chan interface{}
```

_Пример использования функции:_
```go
sig := func(after time.Duration) &lt;-chan interface{} {
  c := make(chan interface{})
  go func() {
    defer close(c)
    time.Sleep(after)
  }()
  return c
}

start := time.Now()
&lt;-or(
  sig(2*time.Hour),
  sig(5*time.Minute),
  sig(1*time.Second),
  sig(1*time.Hour),
  sig(1*time.Minute),
)
fmt.Printf("done after %v", time.Since(start))
```

В этом примере канал, возвращённый or(...), закроется через ~1 секунду, потому что самый короткий канал sig(1*time.Second) закроется первым. Ваша реализация or должна уметь принимать на вход произвольное число каналов и завершаться при сигнале на любом из них.

**Подсказка:** используйте select в бесконечном цикле для чтения из всех каналов одновременно, либо рекурсивно объединяйте каналы попарно.

---

## 2.15 **Minishell: взаимодействие с ОС**

> **Задача:** Необходимо реализовать собственный простейший **Unix shell**.

### Требования
**Ваш интерпретатор командной строки должен поддерживать:**
* **Встроенные команды:**
  * – cd <path> – смена текущей директории.
  * – pwd – вывод текущей директории.
  * – echo <args> – вывод аргументов.
  * – kill <pid> – послать сигнал завершения процессу с заданным PID.
  * – ps – вывести список запущенных процессов.

* Запуск внешних команд через exec (с помощью системных вызовов fork/exec либо стандартных функций os/exec).

* Конвейеры (pipelines): возможность объединять команды через |, чтобы вывод одной команды направлять на ввод следующей (как в обычном shell).

* Например: ps | grep myprocess | wc -l.

* Обработку завершения: при нажатии Ctrl+D (EOF) шелл должен завершаться; Ctrl+C — прерывание текущей запущенной команды, но без закрыватия самой shell.

**Дополнительно:** реализовать парсинг && и || (условное выполнение команд), подстановку переменных окружения $VAR, поддержку редиректов >/< для вывода в файл и чтения из файла.

Основной упор необходимо делать на реализацию базового функционала (exec, builtins, pipelines). Проверять надо как интерактивно, так и скриптом. Код должен работать без ситуаций гонки, корректно освобождать ресурсы. 

**Совет:** используйте пакеты os/exec, bufio (для ввода), strings.Fields (для разбиения командной строки на аргументы) и системные вызовы через syscall, если потребуется.

---

## 2.16 **Утилита wget (упрощенная)**

> **Задача:** Реализовать утилиту загрузки веб-страниц **вместе со всем вложенным контентом** (ресурсы, ссылки), аналогичную wget -m (мирроринг сайта).

### Требования
* Программа должна принимать URL и, возможно, глубину рекурсии (количество уровней ссылок, которые нужно скачать).

* Должна уметь скачивать HTML-страницы, сохранять их локально, а также рекурсивно скачивать ресурсы: CSS, JS, изображения и т.д., а так же страницы, на которые есть ссылки (в рамках того же домена).

* На выходе должен получиться локальный каталог, содержащий копию сайта (или его части), чтобы страницу можно было открыть офлайн.

* Необходимо обрабатывать различные нюансы: относительные и абсолютные ссылки, дублирование (не скачивать один и тот же ресурс несколько раз), корректно формировать локальные пути для сохранения, избегать зацикливания по ссылкам.

* Опционально: поддержать параллельное скачивание (например, ограничить до N одновременных загрузок), управлять robots.txt и пр.

Эта задача проверяет навыки сетевого программирования (HTTP-запросы), работы с файлами и строками, а также проектирования (нужно спланировать структуру, как хранить информацию о посещенных URL, как сохранять файлы и менять ссылки внутри HTML на локальные и т.д.).

Постарайтесь разбить программу на функции и пакеты: например, парсер HTML, загрузчик и т.п.

Обязательно учтите обработку ошибок (сетевых, файловых) и время выполнения (можно добавить таймауты на запросы).

---

## 2.17 **Утилита telnet (примитивный telnet-клиент)**

> **Задача:** Реализовать простой telnet-клиент с возможностью соединяться к TCP-серверу и взаимодействовать с ним:

* Программа должна принимать параметры: хост, порт и опционально таймаут соединения (через флаг --timeout, по умолчанию 10 секунд).

* После запуска, telnet-клиент устанавливает TCP-соединение с указанным host:port.

* Все, что пользователь вводит в STDIN, должно отправляться в сокет; все, что приходит из сокета — печататься в STDOUT.

* При нажатии комбинации клавиш Ctrl+D клиент должен закрыть соединение и завершиться. Если сервер закрыл соединение, клиент тоже завершается.

* В случае, если попытка подключения не удалась (например, сервер недоступен) — программа завершается через заданный timeout с соответствующим сообщением об ошибке.

Проверить программу можно, например, подключившись к какому-нибудь публичному echo-серверу или SMTP (порт: 25) и вручную отправляя команды.

Обратите внимание на обработку буферов: желательно запускать чтение/запись в отдельных горутинах (для конкурентного ввода/вывода). Код должен быть без гонок. Реализация данной утилиты подразумевает использование пакета net (тип net.Conn), и возможно bufio для удобства чтения/записи.

---

## 2.18 **HTTP-сервер «Календарь»**

> **Задача:** Реализовать HTTP-сервер для работы с небольшим календарем событий.
В рамках задания необходимо:

### **CRUD операции для событий**
* POST /create_event — создание нового события;
* POST /update_event — обновление существующего;
* POST /delete_event — удаление;
* GET /events_for_day — получить все события на день;
* GET /events_for_week — события на неделю;
* GET /events_for_month — события на месяц.

### **Формат запросов**
Данные для создания/обновления передаются в теле запроса в виде URL-формы (application/x-www-form-urlencoded), либо JSON (на выбор).

Например, для создания события могут требоваться user_id, date (YYYY-MM-DD), event (текст). Для GET-запросов параметры могут передаваться через query string, например ?user_id=1&date=2023-12-31

### **Возвращаемый результат**
В случае успешного выполнения — JSON вида {"result": "..."}, в случае ошибки бизнес-логики — {"error": "описание ошибки"}.

**HTTP статус-коды:**
* 200 OK для успешных запросов;
* 400 для ошибок ввода (например, некорректный date);
* 503 для ошибок бизнес-логики (например, попытка удалить несуществующее событие);
* 500 для прочих ошибок.

### **Логика**
Можно хранить события в памяти (например, в срезе или map).

User_id — условно идентификатор пользователя календаря (можно игнорировать сложные права доступа в этой задаче). Под «событием» можно понимать запись с датой и текстом или более сложную структуру по желанию.

### **Middleware логирования**
Реализовать middleware, который логирует каждый запрос (метод, URL, время) на stdout или в файл.

### Общие требования
* Сервер должен запускаться на порту, указанном в конфигурации (например, через переменную окружения или флаг).

* Бизнес-логика (функции, которые добавляют/изменяют/удаляют события и т.д.) не должна зависеть от HTTP слоя — т.е. вынесите её в отдельный пакет/структуру, а в обработчиках только вызывайте её методы.

* Код должен быть чистым, проверенным (vet, lint), без data race. Обязательно покрыть unit-тестами хотя бы основные функции бизнес-логики (например, добавление и выборку событий).
